<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bitcoin Price Projection (Supply–Demand Model, Improved)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      --maxw: 920px;
      --accent: #ff7a00;
      --text: #222;
      --muted: #666;
      --bg: #fff;
      --card: #f7f7f9;
      --border: #e5e7eb;
    }
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0;
      color: var(--text);
      background: var(--bg);
      line-height: 1.45;
    }
    header, main {
      max-width: var(--maxw);
      margin: 0 auto;
      padding: 16px;
    }
    header h1 {
      margin: 16px 0 8px;
      font-size: clamp(1.2rem, 2.5vw, 1.8rem);
    }
    header p {
      margin: 0 0 10px;
      color: var(--muted);
      font-size: 0.95rem;
    }
    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    @media (min-width: 860px) {
      .grid {
        grid-template-columns: 1fr 1fr;
      }
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px;
    }
    .section-title {
      margin: 0 0 6px;
      font-weight: 700;
      font-size: 1rem;
    }
    .slider-container, .select-container, .toggle-row {
      margin: 10px 0 14px;
    }
    label {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
      font-weight: 600;
      font-size: 0.95rem;
    }
    .param-desc {
      margin: 6px 0 10px;
      color: var(--muted);
      font-size: 0.9rem;
    }
    input[type="range"] {
      width: 100%;
    }
    select, input[type="number"] {
      width: 100%;
      padding: 8px 10px;
      font-size: 0.95rem;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: #fff;
    }
    output {
      font-weight: 700;
      color: var(--accent);
      white-space: nowrap;
    }
    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .row-3 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }
    .muted {
      color: var(--muted);
      font-size: 0.9rem;
    }
    .results {
      display: grid;
      gap: 8px;
      grid-template-columns: 1fr;
    }
    .result-item {
      display: flex;
      justify-content: space-between;
      border-bottom: 1px dashed var(--border);
      padding: 6px 0;
      font-size: 0.96rem;
    }
    canvas { width: 100% !important; height: 380px !important; }
    .legend {
      margin-top: 8px;
      color: var(--muted);
      font-size: 0.9rem;
    }
    .micro {
      font-size: 0.85rem;
      color: var(--muted);
    }
  </style>
</head>
<body>
<header>
  <h1>Bitcoin Price Projection (Supply–Demand Model)</h1>
  <p>Explore how user growth, USD debasement, and liquid supply affect price. The model is pedagogical, not investment advice.</p>
</header>

<main class="grid">
  <section class="card">
    <h2 class="section-title">Core Assumptions</h2>

    <div class="slider-container">
      <label for="p0">Initial Price P₀ (USD)
        <output id="p0-value">$115,000</output>
      </label>
      <p class="param-desc">Starting BTC price in USD (nominal).</p>
      <input type="range" id="p0" min="10000" max="200000" step="1000" value="115000">
    </div>

    <div class="slider-container">
      <label for="u0">Initial Users U₀ (millions)
        <output id="u0-value">600</output>
      </label>
      <p class="param-desc">Estimated current global BTC users/participants.</p>
      <input type="range" id="u0" min="100" max="1000" step="10" value="600">
    </div>

    <div class="slider-container">
      <label for="alpha">Network Exponent α
        <output id="alpha-value">1.80</output>
      </label>
      <p class="param-desc">Strength of network effects: α≈1–2. Metcalfe’s Law implies α near 2.</p>
      <input type="range" id="alpha" min="0.5" max="2.5" step="0.05" value="1.8">
    </div>

    <div class="slider-container">
      <label for="d">USD Debasement d (annual)
        <output id="d-value">0.04 (4%)</output>
      </label>
      <p class="param-desc">Nominal USD inflation/debasement factor applied to price.</p>
      <input type="range" id="d" min="0" max="0.2" step="0.01" value="0.04">
    </div>

    <div class="slider-container">
      <label for="t">Time Horizon T (years)
        <output id="t-value">10</output>
      </label>
      <input type="range" id="t" min="1" max="20" step="1" value="10">
    </div>

    <div class="select-container">
      <label for="growth-type">User Growth Model
        <output id="growth-type-value">Constant</output>
      </label>
      <select id="growth-type">
        <option value="constant">Constant</option>
        <option value="logistic">Logistic</option>
      </select>
      <div id="constant-controls">
        <div class="slider-container">
          <label for="g">Annual User Growth g
            <output id="g-value">0.10 (10%)</output>
          </label>
          <input type="range" id="g" min="0" max="0.5" step="0.01" value="0.10">
        </div>
      </div>
      <div id="logistic-controls" style="display:none">
        <div class="slider-container">
          <label for="k">Carrying Capacity K (millions)
            <output id="k-value">4000</output>
          </label>
          <input type="range" id="k" min="1000" max="8000" step="100" value="4000">
        </div>
        <div class="slider-container">
          <label for="r">Intrinsic Growth Rate r
            <output id="r-value">0.29</output>
          </label>
          <input type="range" id="r" min="0.1" max="0.7" step="0.01" value="0.29">
        </div>
      </div>
    </div>
  </section>

  <section class="card">
    <h2 class="section-title">Supply Dynamics</h2>

    <div class="select-container">
      <label for="supply-model">Supply Model
        <output id="supply-model-value">Constant</output>
      </label>
      <select id="supply-model">
        <option value="constant">Constant float</option>
        <option value="halving">Emissions + halving + reserves</option>
      </select>
    </div>

    <div id="halving-controls" style="display:none">
      <div class="slider-container">
        <label for="reserves-rate">Reserves Rate (BTC/day)
          <output id="reserves-rate-value">300</output>
        </label>
        <p class="param-desc">Net BTC/day moved into long-term illiquid reserves (ETFs, institutions, HODL).</p>
        <input type="range" id="reserves-rate" min="0" max="1000" step="10" value="300">
      </div>

      <div class="slider-container">
        <label for="gamma">Supply Elasticity γ
          <output id="gamma-value">1.50</output>
        </label>
        <p class="param-desc">Price sensitivity to changes in liquid float. Higher γ → tighter float boosts price more.</p>
        <input type="range" id="gamma" min="0" max="5" step="0.1" value="1.5">
      </div>

      <div class="slider-container">
        <label for="lost-rate">Lost/Attrition of Liquid (%/yr)
          <output id="lost-rate-value">0.20%</output>
        </label>
        <p class="param-desc">Proxy for coins becoming inaccessible or aging into illiquidity.</p>
        <input type="range" id="lost-rate" min="0" max="2" step="0.05" value="0.2">
      </div>

      <p class="micro">Halving cadence here is approximated annually (~210k blocks ≈ 3.99 years). For higher fidelity, switch to sub-annual steps.</p>
    </div>
  </section>

  <section class="card" style="grid-column: 1 / -1;">
    <h2 class="section-title">Results</h2>

    <div class="results">
      <div class="result-item">
        <span>Final Price P(T) — Nominal</span>
        <strong id="final-price-nom">$0</strong>
      </div>
      <div class="result-item">
        <span>Final Price P(T) — Real (excl. debasement)</span>
        <strong id="final-price-real">$0</strong>
      </div>
      <div class="result-item">
        <span>CAGR — Nominal</span>
        <strong id="arr-nom">~0%</strong>
      </div>
      <div class="result-item">
        <span>CAGR — Real</span>
        <strong id="arr-real">~0%</strong>
      </div>
      <div class="result-item">
        <span>Final Users U(T) (millions)</span>
        <strong id="final-users">0</strong>
      </div>
      <div class="result-item">
        <span>Final Liquid Supply Sᶫ(T) (millions of BTC)</span>
        <strong id="final-liquid">0.00</strong>
      </div>
    </div>

    <div style="margin-top:12px">
      <canvas id="price-chart"></canvas>
      <div class="legend">Orange: Nominal price. Blue: Real price (excl. debasement). Both use the same demand/liquidity structure.</div>
    </div>
  </section>
</main>

<script>
  // Elements
  const p0Input = document.getElementById('p0');
  const u0Input = document.getElementById('u0');
  const alphaInput = document.getElementById('alpha');
  const dInput = document.getElementById('d');
  const tInput = document.getElementById('t');

  const growthTypeSelect = document.getElementById('growth-type');
  const gInput = document.getElementById('g');
  const kInput = document.getElementById('k');
  const rInput = document.getElementById('r');

  const supplyModelSelect = document.getElementById('supply-model');
  const reservesRateInput = document.getElementById('reserves-rate');
  const gammaInput = document.getElementById('gamma');
  const lostRateInput = document.getElementById('lost-rate');

  const p0Value = document.getElementById('p0-value');
  const u0Value = document.getElementById('u0-value');
  const alphaValue = document.getElementById('alpha-value');
  const dValue = document.getElementById('d-value');
  const tValue = document.getElementById('t-value');
  const growthTypeValue = document.getElementById('growth-type-value');
  const gValue = document.getElementById('g-value');
  const kValue = document.getElementById('k-value');
  const rValue = document.getElementById('r-value');

  const supplyModelValue = document.getElementById('supply-model-value');
  const reservesRateValue = document.getElementById('reserves-rate-value');
  const gammaValue = document.getElementById('gamma-value');
  const lostRateValue = document.getElementById('lost-rate-value');

  const constantControls = document.getElementById('constant-controls');
  const logisticControls = document.getElementById('logistic-controls');
  const halvingControls = document.getElementById('halving-controls');

  const finalNomEl = document.getElementById('final-price-nom');
  const finalRealEl = document.getElementById('final-price-real');
  const arrNomEl = document.getElementById('arr-nom');
  const arrRealEl = document.getElementById('arr-real');
  const finalUsersEl = document.getElementById('final-users');
  const finalLiquidEl = document.getElementById('final-liquid');

  // Chart setup
  const ctx = document.getElementById('price-chart').getContext('2d');
  const chart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [
        {
          label: 'Nominal Price',
          data: [],
          borderColor: 'orange',
          backgroundColor: 'rgba(255,122,0,0.1)',
          fill: false,
          tension: 0.15
        },
        {
          label: 'Real Price',
          data: [],
          borderColor: '#1f77b4',
          backgroundColor: 'rgba(31,119,180,0.1)',
          fill: false,
          tension: 0.15
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: false,
          title: { display: true, text: 'Price (USD)' },
          ticks: { callback: (v) => formatUSD(v) }
        },
        x: { title: { display: true, text: 'Years' } }
      },
      plugins: {
        legend: { display: true }
      }
    }
  });

  // Constants and assumptions
  const initialSupplyBTC = 19_933_250;    // Approx Oct 2025 circulating
  const initialIlliquidBTC = 14_300_000;  // Estimated illiquid stock
  const initialLiquidBTC = Math.max(initialSupplyBTC - initialIlliquidBTC, 0);

  // Mining parameters (simplified)
  const blocksPerYear = 52_560; // ~144 blocks/day * 365
  const initialReward = 3.125;  // BTC per block post-2024 halving
  const yearsPerHalving = 3.99; // ~210k blocks / (144*365)

  function formatUSD(x) {
    try {
      return new Intl.NumberFormat(undefined, { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(x);
    } catch {
      return '$' + Math.round(x).toLocaleString();
    }
  }

  function formatPct(p) {
    return `${(p * 100).toFixed(0)}%`;
  }

  function clamp(x, min, max) {
    return Math.min(Math.max(x, min), max);
  }

  // Compute users for year t
  function usersAt(t, model, params) {
    const u0 = params.u0;
    if (model === 'constant') {
      const g = params.g;
      return u0 * Math.pow(1 + g, t);
    } else {
      const K = params.k;
      const r = params.r;
      // Logistic: U(t) = K / (1 + ((K/U0) - 1)*e^{-rt})
      return K / (1 + ((K / u0) - 1) * Math.exp(-r * t));
    }
  }

  // Approx halving reward by year with fractional cadence
  function rewardAtYear(t) {
    // Number of halvings elapsed from t=0
    const halvings = Math.floor(t / yearsPerHalving);
    return initialReward / Math.pow(2, halvings);
  }

  // Simulate supply stocks year by year
  function simulateSupply(T, supplyMode, reservesPerDay, lostPctPerYear) {
    let total = initialSupplyBTC;
    let illiq = initialIlliquidBTC;
    let liq = initialLiquidBTC;

    // Track yearly liquid for plotting and pricing
    const liquidByYear = [liq];

    if (supplyMode === 'constant') {
      for (let y = 1; y <= T; y++) {
        // no emissions, no reserves changes
        liquidByYear.push(liq);
      }
      return { liquidByYear, finalLiquid: liq, finalTotal: total };
    }

    // Halving mode: emissions + reserves + losses
    for (let y = 1; y <= T; y++) {
      const rew = rewardAtYear(y - 0.0001); // reward near start of year y
      const flow = rew * blocksPerYear;     // BTC mined within year y

      total += flow;

      // Reserves absorption: cannot exceed available liquid after adding flow
      const reservesAnnual = reservesPerDay * 365;
      const available = liq + flow;
      const reservesApplied = clamp(reservesAnnual, 0, Math.max(available, 0));

      // Update liquid: add flow, subtract reserves
      liq = liq + flow - reservesApplied;

      // Lost/attrition from remaining liquid
      const lost = liq * (lostPctPerYear / 100);
      liq = Math.max(liq - lost, 0);

      // Illiquid increases by reserves + lost, but do not exceed total
      illiq = clamp(illiq + reservesApplied + lost, 0, total);

      // Optional soft floor: ensure some minimum trading float, e.g., 5% of supply
      const minFloat = 0.05 * total;
      if (liq < minFloat) {
        const delta = minFloat - liq;
        const reducible = Math.max(illiq - 0, 0);
        const shift = Math.min(delta, reducible);
        // Move coins from illiquid back to liquid to avoid zero-float corner cases
        liq += shift;
        illiq -= shift;
      }

      liquidByYear.push(liq);
    }

    return { liquidByYear, finalLiquid: liq, finalTotal: total };
  }

  function updateUIValues() {
    const p0 = Number(p0Input.value);
    const u0 = Number(u0Input.value);
    const alpha = Number(alphaInput.value);
    const d = Number(dInput.value);
    const T = Number(tInput.value);

    p0Value.textContent = formatUSD(p0);
    u0Value.textContent = u0.toLocaleString();
    alphaValue.textContent = alpha.toFixed(2);
    dValue.textContent = `${d.toFixed(2)} (${(d * 100).toFixed(0)}%)`;
    tValue.textContent = T.toString();

    const growthType = growthTypeSelect.value;
    growthTypeValue.textContent = growthType.charAt(0).toUpperCase() + growthType.slice(1);

    if (growthType === 'constant') {
      constantControls.style.display = 'block';
      logisticControls.style.display = 'none';
      gValue.textContent = `${Number(gInput.value).toFixed(2)} (${(Number(gInput.value) * 100).toFixed(0)}%)`;
    } else {
      constantControls.style.display = 'none';
      logisticControls.style.display = 'block';
      kValue.textContent = Number(kInput.value).toLocaleString();
      rValue.textContent = Number(rInput.value).toFixed(2);
    }

    const supplyModel = supplyModelSelect.value;
    supplyModelValue.textContent = supplyModel === 'constant' ? 'Constant float' : 'Emissions + halving + reserves';
    halvingControls.style.display = supplyModel === 'halving' ? 'block' : 'none';

    reservesRateValue.textContent = Number(reservesRateInput.value).toLocaleString();
    gammaValue.textContent = Number(gammaInput.value).toFixed(2);
    lostRateValue.textContent = `${Number(lostRateInput.value).toFixed(2)}%`;
  }

  function updateModel() {
    updateUIValues();

    const p0 = Number(p0Input.value);
    const u0 = Number(u0Input.value);
    const alpha = Number(alphaInput.value);
    const d = Number(dInput.value);
    const T = Number(tInput.value);

    const growthType = growthTypeSelect.value;
    const g = Number(gInput.value);
    const k = Number(kInput.value);
    const r = Number(rInput.value);

    const supplyMode = supplyModelSelect.value;
    const reservesPerDay = Number(reservesRateInput.value);
    const gamma = Number(gammaInput.value);
    const lostPct = Number(lostRateInput.value);

    // Users and supply over time
    const labels = Array.from({ length: T + 1 }, (_, i) => i);
    const users = labels.map((t) => usersAt(t, growthType, { u0, g, k, r }));

    // Simulate liquid supply by year
    const { liquidByYear } = simulateSupply(T, supplyMode, reservesPerDay, lostPct);
    const liquid0 = liquidByYear[0] || initialLiquidBTC;

    // Price model:
    // Real price P_real(t) = P0 * (U(t)/U0)^α * FloatFactor(t)
    // where FloatFactor(t) = (Liquid0 / Liquid(t))^γ  if halving mode, else 1
    // Nominal price P_nom(t) = P_real(t) * (1 + d)^t
    const realPrices = [];
    const nomPrices = [];
    for (let t = 0; t <= T; t++) {
      const Ut = users[t];
      const netExp = Math.pow(Ut / u0, alpha);

      let floatFactor = 1;
      if (supplyMode === 'halving') {
        const Lt = Math.max(liquidByYear[t], 1); // avoid /0
        floatFactor = Math.pow(liquid0 / Lt, gamma);
        // Optional saturation to avoid runaway (cap at 50x)
        floatFactor = clamp(floatFactor, 0.02, 50);
      }

      const P_real_t = p0 * netExp * floatFactor;
      const P_nom_t = P_real_t * Math.pow(1 + d, t);

      realPrices.push(P_real_t);
      nomPrices.push(P_nom_t);
    }

    // Update chart
    chart.data.labels = labels;
    chart.data.datasets[0].data = nomPrices;
    chart.data.datasets[1].data = realPrices;
    chart.update();

    // Results
    const P_nom_T = nomPrices[nomPrices.length - 1];
    const P_real_T = realPrices[realPrices.length - 1];

    // Nominal CAGR is based on P_nom
    const arrNom = Math.pow(P_nom_T / p0, 1 / T) - 1;

    // Real P0 is p0 (since at t=0 (1+d)^0 = 1); so real CAGR uses P_real
    const arrReal = Math.pow(P_real_T / p0, 1 / T) - 1;

    finalNomEl.textContent = formatUSD(P_nom_T);
    finalRealEl.textContent = formatUSD(P_real_T);
    arrNomEl.textContent = `~${(arrNom * 100).toFixed(0)}%`;
    arrRealEl.textContent = `~${(arrReal * 100).toFixed(0)}%`;

    const U_T = users[users.length - 1];
    finalUsersEl.textContent = Math.round(U_T).toLocaleString();

    const L_T = (simulateSupply(T, supplyMode, reservesPerDay, lostPct).finalLiquid) / 1_000_000;
    finalLiquidEl.textContent = L_T.toFixed(2);
  }

  // Event listeners
  [
    p0Input, u0Input, alphaInput, dInput, tInput,
    growthTypeSelect, gInput, kInput, rInput,
    supplyModelSelect, reservesRateInput, gammaInput, lostRateInput
  ].forEach(el => el.addEventListener('input', updateModel));

  // Initial render
  updateModel();
</script>
</body>
</html>
