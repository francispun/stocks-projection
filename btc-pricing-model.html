<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Price Projection Model (Updated)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 20px auto; padding: 10px; }
        #chart-container { width: 100%; height: 400px; }
        .slider-container { margin: 10px 0; }
        label { display: block; font-weight: bold; }
        output { font-weight: bold; color: #007bff; }
        details { margin: 20px 0; padding: 10px; border: 1px solid #ccc; border-radius: 5px; }
        summary { cursor: pointer; font-weight: bold; }
        ul { margin: 10px 0; padding-left: 20px; }
    </style>
</head>
<body>
    <h1>Bitcoin Price Projection Model (Metcalfe's Law)</h1>
    <p>Adjust sliders and toggle growth type to project Bitcoin's price. The chart and results update automatically.</p>

    <details>
        <summary>Parameter Explanations</summary>
        <p>This model uses Metcalfe's Law (price grows with the square of users) to project Bitcoin's price. Below are the adjustable inputs:</p>
        <ul>
            <li><strong>Initial Price (P₀)</strong>: Starting Bitcoin price in USD (default: $115,000, current as of Oct 2025). Sets the baseline for projections.</li>
            <li><strong>Initial Users (U₀)</strong>: Starting number of users in millions (default: 600). Scales the network's value.</li>
            <li><strong>Time Horizon (T)</strong>: Years to project (default: 10). Defines the forecast period.</li>
            <li><strong>Growth Type</strong>: Choose "Constant" (steady user growth) or "Logistic" (growth slows as it nears a limit, more realistic).</li>
            <li><strong>Annual Growth Rate (g)</strong> (Constant mode): Yearly user growth rate (default: 0.14 or 14%). Higher means faster adoption.</li>
            <li><strong>Carrying Capacity (K)</strong> (Logistic mode): Max potential users in millions (default: 4,000). Limits growth as adoption saturates.</li>
            <li><strong>Intrinsic Rate (r)</strong> (Logistic mode): Early growth speed (default: 0.29). Higher means faster initial takeoff.</li>
        </ul>
        <p>Outputs like ARR (annualized return) and final price/users update as you adjust sliders. Try different values to explore scenarios!</p>
    </details>

    <div class="slider-container">
        <label for="p0">Initial Price (P₀ in USD): <output id="p0-value">115000</output></label>
        <input type="range" id="p0" min="10000" max="200000" step="1000" value="115000">
    </div>

    <div class="slider-container">
        <label for="u0">Initial Users (U₀ in millions): <output id="u0-value">600</output></label>
        <input type="range" id="u0" min="100" max="1000" step="10" value="600">
    </div>

    <div class="slider-container">
        <label for="growth-type">Growth Type: <output id="growth-type-value">Constant</output></label>
        <select id="growth-type">
            <option value="constant">Constant</option>
            <option value="logistic">Logistic</option>
        </select>
    </div>

    <div id="constant-controls">
        <div class="slider-container">
            <label for="g">Annual Growth Rate (g): <output id="g-value">0.14</output> (14%)</label>
            <input type="range" id="g" min="0" max="0.5" step="0.01" value="0.14">
        </div>
    </div>

    <div id="logistic-controls" style="display: none;">
        <div class="slider-container">
            <label for="k">Carrying Capacity (K in millions): <output id="k-value">4000</output></label>
            <input type="range" id="k" min="1000" max="8000" step="100" value="4000">
        </div>
        <div class="slider-container">
            <label for="r">Intrinsic Rate (r): <output id="r-value">0.29</output></label>
            <input type="range" id="r" min="0.1" max="0.5" step="0.01" value="0.29">
        </div>
    </div>

    <div class="slider-container">
        <label for="t">Time Horizon (T in years): <output id="t-value">10</output></label>
        <input type="range" id="t" min="1" max="20" step="1" value="10">
    </div>

    <h2>Results</h2>
    <p>Effective ARR (Price CAGR): <output id="arr">~30%</output></p>
    <p>Final Price (P_T): <output id="final-price">$1,391,000</output></p>
    <p>Final Users (U_T in millions): <output id="final-users">2090</output></p>

    <div id="chart-container">
        <canvas id="price-chart"></canvas>
    </div>

    <script>
        // Get elements
        const p0Input = document.getElementById('p0');
        const u0Input = document.getElementById('u0');
        const growthTypeSelect = document.getElementById('growth-type');
        const gInput = document.getElementById('g');
        const kInput = document.getElementById('k');
        const rInput = document.getElementById('r');
        const tInput = document.getElementById('t');
        const p0Value = document.getElementById('p0-value');
        const u0Value = document.getElementById('u0-value');
        const growthTypeValue = document.getElementById('growth-type-value');
        const gValue = document.getElementById('g-value');
        const kValue = document.getElementById('k-value');
        const rValue = document.getElementById('r-value');
        const tValue = document.getElementById('t-value');
        const arrOutput = document.getElementById('arr');
        const finalPriceOutput = document.getElementById('final-price');
        const finalUsersOutput = document.getElementById('final-users');
        const constantControls = document.getElementById('constant-controls');
        const logisticControls = document.getElementById('logistic-controls');

        // Chart setup
        const ctx = document.getElementById('price-chart').getContext('2d');
        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Projected BTC Price',
                    data: [],
                    borderColor: 'orange',
                    fill: false
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: { beginAtZero: false, title: { display: true, text: 'Price (USD)' } },
                    x: { title: { display: true, text: 'Years' } }
                }
            }
        });

        // Toggle controls
        growthTypeSelect.addEventListener('change', () => {
            const type = growthTypeSelect.value;
            growthTypeValue.textContent = type.charAt(0).toUpperCase() + type.slice(1);
            constantControls.style.display = type === 'constant' ? 'block' : 'none';
            logisticControls.style.display = type === 'logistic' ? 'block' : 'none';
            updateModel();
        });

        // Update function
        function updateModel() {
            const p0 = parseFloat(p0Input.value);
            const u0 = parseFloat(u0Input.value);
            const type = growthTypeSelect.value;
            const T = parseInt(tInput.value);

            // Update displayed values
            p0Value.textContent = p0.toLocaleString();
            u0Value.textContent = u0.toLocaleString();
            tValue.textContent = T;

            let labels = [];
            let data = [];
            let finalUsers;

            if (type === 'constant') {
                const g = parseFloat(gInput.value);
                gValue.textContent = g.toFixed(2) + ` (${(g * 100).toFixed(0)}%)`;
                for (let t = 0; t <= T; t++) {
                    labels.push(t);
                    const price = p0 * Math.pow(1 + g, 2 * t);
                    data.push(price);
                }
                finalUsers = u0 * Math.pow(1 + g, T);
            } else {
                const k = parseFloat(kInput.value);
                const r = parseFloat(rInput.value);
                kValue.textContent = k.toLocaleString();
                rValue.textContent = r.toFixed(2);
                for (let t = 0; t <= T; t++) {
                    labels.push(t);
                    const ut = k / (1 + ((k / u0) - 1) * Math.exp(-r * t));
                    const price = p0 * Math.pow(ut / u0, 2);
                    data.push(price);
                }
                finalUsers = k / (1 + ((k / u0) - 1) * Math.exp(-r * T));
            }

            // Update chart
            chart.data.labels = labels;
            chart.data.datasets[0].data = data;
            chart.update();

            // Calculate effective ARR (CAGR for price)
            const finalPrice = data[data.length - 1];
            const arr = Math.pow(finalPrice / p0, 1 / T) - 1;
            arrOutput.textContent = `~${(arr * 100).toFixed(0)}%`;

            // Update outputs
            finalPriceOutput.textContent = `$${Math.round(finalPrice).toLocaleString()}`;
            finalUsersOutput.textContent = Math.round(finalUsers).toLocaleString();
        }

        // Event listeners
        p0Input.addEventListener('input', updateModel);
        u0Input.addEventListener('input', updateModel);
        gInput.addEventListener('input', updateModel);
        kInput.addEventListener('input', updateModel);
        rInput.addEventListener('input', updateModel);
        tInput.addEventListener('input', updateModel);

        // Initial update
        updateModel();
    </script>
</body>
</html>
