<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Price Projection Model (Supply-Demand Framework)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 20px auto; padding: 10px; }
        #chart-container { width: 100%; height: 400px; }
        .slider-container { margin: 20px 0; }
        label { display: block; font-weight: bold; }
        output { font-weight: bold; color: #007bff; }
        .param-desc { font-size: 0.9em; color: #555; margin: 5px 0 10px 0; }
        #halving-controls { display: none; }
    </style>
</head>
<body>
    <h1>Bitcoin Price Projection Model (Supply-Demand Framework)</h1>
    <p>Adjust sliders and toggles to project Bitcoin's price. The chart and results update automatically.</p>

    <div class="slider-container">
        <label for="p0">Initial Price (P₀ in USD): <output id="p0-value">115000</output></label>
        <p class="param-desc">Starting Bitcoin price in USD (real-world: today's market price from exchanges like Coinbase; default based on Oct 2025 data).</p>
        <input type="range" id="p0" min="10000" max="200000" step="1000" value="115000">
    </div>

    <div class="slider-container">
        <label for="u0">Initial Users (U₀ in millions): <output id="u0-value">600</output></label>
        <p class="param-desc">Estimated starting number of Bitcoin users/network participants (real-world: global crypto users ~560M in 2024, with BTC dominating; adjust for your estimate).</p>
        <input type="range" id="u0" min="100" max="1000" step="10" value="600">
    </div>

    <div class="slider-container">
        <label for="d">Debasement Rate (d): <output id="d-value">0.04</output> (4%)</label>
        <p class="param-desc">Annual percentage loss in USD purchasing power (real-world: inflation rate, ~2.4% CPI in 2025, but 4-6% reflects felt costs or money supply growth).</p>
        <input type="range" id="d" min="0" max="0.2" step="0.01" value="0.04">
    </div>

    <div class="slider-container">
        <label for="growth-type">Growth Type: <output id="growth-type-value">Constant</output></label>
        <p class="param-desc">Select how users grow: "Constant" for steady rate (real-world: like early internet) or "Logistic" for decelerating toward a limit (real-world: like smartphone saturation).</p>
        <select id="growth-type">
            <option value="constant">Constant</option>
            <option value="logistic">Logistic</option>
        </select>
    </div>

    <div id="constant-controls">
        <div class="slider-container">
            <label for="g">Annual Growth Rate (g): <output id="g-value">0.10</output> (10%)</label>
            <p class="param-desc">Yearly percentage increase in users (real-world: crypto grew ~33% in 2024; expect 5-15% as it matures, like internet post-2000s).</p>
            <input type="range" id="g" min="0" max="0.5" step="0.01" value="0.10">
        </div>
    </div>

    <div id="logistic-controls" style="display: none;">
        <div class="slider-container">
            <label for="k">Carrying Capacity (K in millions): <output id="k-value">4000</output></label>
            <p class="param-desc">Maximum potential global users (real-world: ~half world's 8B population, as not everyone may adopt BTC, similar to internet penetration).</p>
            <input type="range" id="k" min="1000" max="8000" step="100" value="4000">
        </div>
        <div class="slider-container">
            <label for="r">Intrinsic Rate (r): <output id="r-value">0.29</output></label>
            <p class="param-desc">Controls initial growth speed before slowing (real-world: tuned for 25-30% early growth, like tech adoption booms e.g., early Uber or TikTok).</p>
            <input type="range" id="r" min="0.1" max="0.5" step="0.01" value="0.29">
        </div>
    </div>

    <div class="slider-container">
        <label for="supply-model">Supply Model: <output id="supply-model-value">Constant</output></label>
        <p class="param-desc">How to model BTC supply: "Constant" assumes no new mined BTC (approximation for simplicity); "Halving" includes mining with halving cycles (real-world: halves new supply every ~4 years, slowing dilution from ~0.8% annual inflation now).</p>
        <select id="supply-model">
            <option value="constant">Constant</option>
            <option value="halving">Halving</option>
        </select>
    </div>

    <div id="halving-controls">
        <div class="slider-container">
            <label for="reserves-rate">Reserves Rate (BTC/day): <output id="reserves-rate-value">300</output></label>
            <p class="param-desc">Daily BTC moved to long-term reserves/HODL (real-world: ETFs, institutions accumulate ~285 BTC/day in 2024; forecasts 200-500).</p>
            <input type="range" id="reserves-rate" min="0" max="1000" step="50" value="300">
        </div>
        <div class="slider-container">
            <label for="gamma">Supply Elasticity (γ): <output id="gamma-value">1.5</output></label>
            <p class="param-desc">Sensitivity of price to liquid supply changes (real-world: higher means tighter supply from halvings/HODLing boosts price more, ~1-3 based on historical cycles).</p>
            <input type="range" id="gamma" min="0" max="5" step="0.1" value="1.5">
        </div>
    </div>

    <div class="slider-container">
        <label for="t">Time Horizon (T in years): <output id="t-value">10</output></label>
        <p class="param-desc">Number of years to forecast (real-world: 10 years to 2035 for long-term views, like investment planning horizons).</p>
        <input type="range" id="t" min="1" max="20" step="1" value="10">
    </div>

    <h2>Results</h2>
    <p>Effective ARR (Price CAGR): <output id="arr">~26%</output></p>
    <p>Final Price (P_T): <output id="final-price">$1,110,000</output></p>
    <p>Final Users (U_T in millions): <output id="final-users">1548</output></p>
    <p>Final Liquid Supply (millions of BTC): <output id="final-supply">4.80</output></p>

    <div id="chart-container">
        <canvas id="price-chart"></canvas>
    </div>

    <script>
        // Get elements
        const p0Input = document.getElementById('p0');
        const u0Input = document.getElementById('u0');
        const dInput = document.getElementById('d');
        const growthTypeSelect = document.getElementById('growth-type');
        const supplyModelSelect = document.getElementById('supply-model');
        const reservesRateInput = document.getElementById('reserves-rate');
        const gammaInput = document.getElementById('gamma');
        const gInput = document.getElementById('g');
        const kInput = document.getElementById('k');
        const rInput = document.getElementById('r');
        const tInput = document.getElementById('t');
        const p0Value = document.getElementById('p0-value');
        const u0Value = document.getElementById('u0-value');
        const dValue = document.getElementById('d-value');
        const growthTypeValue = document.getElementById('growth-type-value');
        const supplyModelValue = document.getElementById('supply-model-value');
        const reservesRateValue = document.getElementById('reserves-rate-value');
        const gammaValue = document.getElementById('gamma-value');
        const gValue = document.getElementById('g-value');
        const kValue = document.getElementById('k-value');
        const rValue = document.getElementById('r-value');
        const tValue = document.getElementById('t-value');
        const arrOutput = document.getElementById('arr');
        const finalPriceOutput = document.getElementById('final-price');
        const finalUsersOutput = document.getElementById('final-users');
        const finalSupplyOutput = document.getElementById('final-supply');
        const constantControls = document.getElementById('constant-controls');
        const logisticControls = document.getElementById('logistic-controls');
        const halvingControls = document.getElementById('halving-controls');

        // Chart setup
        const ctx = document.getElementById('price-chart').getContext('2d');
        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Projected BTC Price',
                    data: [],
                    borderColor: 'orange',
                    fill: false
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: { beginAtZero: false, title: { display: true, text: 'Price (USD)' } },
                    x: { title: { display: true, text: 'Years' } }
                }
            }
        });

        // Toggle controls
        growthTypeSelect.addEventListener('change', () => {
            const type = growthTypeSelect.value;
            growthTypeValue.textContent = type.charAt(0).toUpperCase() + type.slice(1);
            constantControls.style.display = type === 'constant' ? 'block' : 'none';
            logisticControls.style.display = type === 'logistic' ? 'block' : 'none';
            updateModel();
        });

        supplyModelSelect.addEventListener('change', () => {
            const type = supplyModelSelect.value;
            supplyModelValue.textContent = type.charAt(0).toUpperCase() + type.slice(1);
            halvingControls.style.display = type === 'halving' ? 'block' : 'none';
            updateModel();
        });

        // Update function
        function updateModel() {
            const p0 = parseFloat(p0Input.value);
            const u0 = parseFloat(u0Input.value);
            const d = parseFloat(dInput.value);
            const reservesRate = parseFloat(reservesRateInput.value);
            const gamma = parseFloat(gammaInput.value);
            const type = growthTypeSelect.value;
            const supplyType = supplyModelSelect.value;
            const T = parseInt(tInput.value);

            // Update displayed values
            p0Value.textContent = p0.toLocaleString();
            u0Value.textContent = u0.toLocaleString();
            dValue.textContent = d.toFixed(2) + ` (${(d * 100).toFixed(0)}%)`;
            reservesRateValue.textContent = reservesRate.toLocaleString();
            gammaValue.textContent = gamma.toFixed(1);
            tValue.textContent = T;

            let labels = [];
            let data = [];
            let finalUsers;
            let finalLiquid;

            const initialSupply = 19933250; // Oct 2025 circulating
            const initialIlliquid = 14300000; // Estimate 14.3M illiquid
            const initialLiquid = initialSupply - initialIlliquid;
            const blocksPerYear = 52560;
            const halvingYears = [3, 7, 11, 15, 19]; // From 2025

            if (type === 'constant') {
                const g = parseFloat(gInput.value);
                gValue.textContent = g.toFixed(2) + ` (${(g * 100).toFixed(0)}%)`;
                for (let t = 0; t <= T; t++) {
                    labels.push(t);
                    const ut = u0 * Math.pow(1 + g, t);
                    let supply = initialSupply;
                    let reward = 3.125;
                    let liquid = initialLiquid;
                    let illiquid = initialIlliquid;
                    if (supplyType === 'halving') {
                        for (let y = 1; y <= t; y++) {
                            let flow = reward * blocksPerYear;
                            supply += flow;
                            const reservesAnnual = reservesRate * 365;
                            const reservesApplied = Math.min(reservesAnnual, liquid + flow);
                            liquid += flow - reservesApplied;
                            illiquid += reservesApplied;
                            const lost = liquid * 0.002; // 0.2%/yr lost coins
                            liquid -= lost;
                            illiquid += lost;
                            if (halvingYears.includes(y)) {
                                reward /= 2;
                            }
                        }
                    }
                    const liquidFactor = (supplyType === 'halving') ? Math.min(Math.pow(initialLiquid / liquid, gamma), 10) : 1;
                    const price = p0 * Math.pow(ut / u0, 2) * Math.pow(1 + d, t) * liquidFactor;
                    data.push(price);
                    if (t === T) {
                        finalUsers = ut;
                        finalLiquid = liquid;
                    }
                }
            } else {
                const k = parseFloat(kInput.value);
                const r = parseFloat(rInput.value);
                kValue.textContent = k.toLocaleString();
                rValue.textContent = r.toFixed(2);
                for (let t = 0; t <= T; t++) {
                    labels.push(t);
                    const ut = k / (1 + ((k / u0) - 1) * Math.exp(-r * t));
                    let supply = initialSupply;
                    let reward = 3.125;
                    let liquid = initialLiquid;
                    let illiquid = initialIlliquid;
                    if (supplyType === 'halving') {
                        for (let y = 1; y <= t; y++) {
                            let flow = reward * blocksPerYear;
                            supply += flow;
                            const reservesAnnual = reservesRate * 365;
                            const reservesApplied = Math.min(reservesAnnual, liquid + flow);
                            liquid += flow - reservesApplied;
                            illiquid += reservesApplied;
                            const lost = liquid * 0.002; // 0.2%/yr lost coins
                            liquid -= lost;
                            illiquid += lost;
                            if (halvingYears.includes(y)) {
                                reward /= 2;
                            }
                        }
                    }
                    const liquidFactor = (supplyType === 'halving') ? Math.min(Math.pow(initialLiquid / liquid, gamma), 10) : 1;
                    const price = p0 * Math.pow(ut / u0, 2) * Math.pow(1 + d, t) * liquidFactor;
                    data.push(price);
                    if (t === T) {
                        finalUsers = ut;
                        finalLiquid = liquid;
                    }
                }
            }

            // Update chart
            chart.data.labels = labels;
            chart.data.datasets[0].data = data;
            chart.update();

            // Calculate effective ARR
            const finalPrice = data[data.length - 1];
            const arr = Math.pow(finalPrice / p0, 1 / T) - 1;
            arrOutput.textContent = `~${(arr * 100).toFixed(0)}% (Nominal)`;

            // Update outputs
            finalPriceOutput.textContent = `$${Math.round(finalPrice).toLocaleString()} (Nominal) / $${Math.round(finalPrice / Math.pow(1 + d, T)).toLocaleString()} (Real)`;
            finalUsersOutput.textContent = Math.round(finalUsers).toLocaleString();
            finalSupplyOutput.textContent = (finalLiquid / 1000000).toFixed(2);
        }

        // Event listeners
        p0Input.addEventListener('input', updateModel);
        u0Input.addEventListener('input', updateModel);
        dInput.addEventListener('input', updateModel);
        reservesRateInput.addEventListener('input', updateModel);
        gammaInput.addEventListener('input', updateModel);
        gInput.addEventListener('input', updateModel);
        kInput.addEventListener('input', updateModel);
        rInput.addEventListener('input', updateModel);
        tInput.addEventListener('input', updateModel);
        growthTypeSelect.addEventListener('change', updateModel);
        supplyModelSelect.addEventListener('change', updateModel);

        // Initial update
        updateModel();
    </script>
</body>
</html>
