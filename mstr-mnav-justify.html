<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simplified MSTR Amplification Simulator</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; }
        .slider-container { margin-bottom: 20px; }
        label { display: block; margin-bottom: 5px; }
        input[type="range"] { width: 100%; }
        .value { font-weight: bold; }
        #result { margin-top: 30px; padding: 15px; background: #f0f0f0; border-radius: 5px; }
        #range { margin-top: 20px; }
    </style>
</head>
<body>
    <h1>Simplified MSTR Amplification Simulator</h1>
    <p>This model simulates MSTR's leverage flywheel over time: BTC grows at g, they pay borrowing costs (c on D), then issue new preferred stock to maintain target amplification (D/A), using proceeds to buy more BTC. This compounds unrealized gains for equity holders faster than pure BTC.</p>
    <p>We calculate:</p>
    <ul>
        <li>Projected BTC NAV (A) after n years.</li>
        <li>Projected Borrowings (D) to keep D/A constant.</li>
        <li>Levered Equity Growth Rate: Effective annual return to shareholders from amplification.</li>
        <li>Fair Current mNAV: PV of future levered equity value discounted at r (your "hurdle rate" for risk), normalized to initial A. Formula: mNAV = [Equity_n / (1+r)^n + PV of interim "benefits"] / initial A, but simplified to focus on terminal equity premium.</li>
    </ul>
    <p>Defaults from your screenshot/discussion. Adjust to see how ongoing issuances amplify gains.</p>

    <div class="slider-container">
        <label for="g">Expected Annual BTC Growth (g): <span id="g-value" class="value">25%</span></label>
        <input type="range" id="g" min="0" max="50" value="25" step="1">
    </div>

    <div class="slider-container">
        <label for="c">Annual Borrowing Cost (c): <span id="c-value" class="value">10%</span></label>
        <input type="range" id="c" min="0" max="20" value="10" step="1">
    </div>

    <div class="slider-container">
        <label for="da">Target Amplification (D/A): <span id="da-value" class="value">23%</span></label>
        <input type="range" id="da" min="0" max="50" value="23" step="1">
    </div>

    <div class="slider-container">
        <label for="r">Your Hurdle Rate (r, for discounting risk): <span id="r-value" class="value">15%</span></label>
        <input type="range" id="r" min="5" max="30" value="15" step="1">
    </div>

    <div class="slider-container">
        <label for="n">Simulation Years (n): <span id="n-value" class="value">10</span></label>
        <input type="range" id="n" min="1" max="20" value="10" step="1">
    </div>

    <div id="result">
        <h2>Projected After <span id="years">10</span> Years:</h2>
        <p>BTC NAV (A): $<span id="a_final">0</span>B (x<span id="a_mult">0</span> initial)</p>
        <p>Borrowings (D): $<span id="d_final">0</span>B</p>
        <p>Equity Value: $<span id="eq_final">0</span>B (levered growth <span id="lev_g">0</span>%/yr)</p>
        <p>Fair Current mNAV: <span id="mnav">1.00</span> (<span id="premium">0</span>% premium)</p>
    </div>

    <div id="range">
        <h3>Example Scenarios</h3>
        <p>Base (g=25%, c=10%, D/A=23%, r=15%, n=10): mNAV ≈1.23 (23% premium)</p>
        <p>Bull (g=30%, c=8%, D/A=30%, r=12%, n=10): mNAV ≈1.42 (42% premium)</p>
        <p>Optimistic Long-Term (g=30%, c=10%, D/A=30%, r=5%, n=20): mNAV ≈2.80 (180% premium)</p>
    </div>

    <script>
        const sliders = {
            g: document.getElementById('g'),
            c: document.getElementById('c'),
            da: document.getElementById('da'),
            r: document.getElementById('r'),
            n: document.getElementById('n')
        };

        const values = {
            g: document.getElementById('g-value'),
            c: document.getElementById('c-value'),
            da: document.getElementById('da-value'),
            r: document.getElementById('r-value'),
            n: document.getElementById('n-value')
        };

        const outputs = {
            years: document.getElementById('years'),
            a_final: document.getElementById('a_final'),
            a_mult: document.getElementById('a_mult'),
            d_final: document.getElementById('d_final'),
            eq_final: document.getElementById('eq_final'),
            lev_g: document.getElementById('lev_g'),
            mnav: document.getElementById('mnav'),
            premium: document.getElementById('premium')
        };

        function updateValues() {
            Object.keys(sliders).forEach(key => {
                if (key === 'n') {
                    values[key].textContent = sliders[key].value;
                } else {
                    values[key].textContent = `${sliders[key].value}%`;
                }
            });
            simulate();
        }

        function simulate() {
            const g = sliders.g.value / 100;
            const c = sliders.c.value / 100;
            const target_da = sliders.da.value / 100;
            const r = sliders.r.value / 100;
            const n = parseInt(sliders.n.value);

            if (r === 0 || g < c) {
                outputs.mnav.textContent = '1.00';
                outputs.premium.textContent = '0';
                return;
            }

            // Initial assumptions: Normalize to $100 initial A
            let A = 100;
            let D = target_da * A;
            let Equity = A - D;

            for (let year = 1; year <= n; year++) {
                // BTC growth
                A *= (1 + g);

                // Pay borrowing cost (assumed covered by issuances or gains, but subtract from equity effectively)
                const interest = c * D;
                Equity -= interest;

                // Issue new borrowing to maintain D/A
                const target_D = target_da * A;
                const new_issue = target_D - D;
                if (new_issue > 0) {
                    // New issue buys more BTC
                    A += new_issue;
                    D += new_issue;
                    Equity -= new_issue; // Dilution from pref issuance (treated as quasi-equity cost)
                } else if (new_issue < 0) {
                    // Rare: Reduce D, but simplify by ignoring
                }
            }

            // Projected finals (scale to billions for realism, assume initial A=65B)
            const scale = 0.65; // Initial A ~65B, for display
            outputs.a_final.textContent = (A * scale).toFixed(1);
            outputs.a_mult.textContent = (A / 100).toFixed(1);
            outputs.d_final.textContent = (D * scale).toFixed(1);
            outputs.eq_final.textContent = (Equity * scale).toFixed(1);

            // Levered growth rate: CAGR of equity
            const lev_g = Math.pow(Equity / (100 - D/ target_da * 100), 1/n) - 1; // Initial equity normalized
            outputs.lev_g.textContent = (lev_g * 100).toFixed(1);

            // Fair current mNAV: PV of final equity premium over pure BTC, simplified
            const pure_btc_eq = (100 * Math.pow(1 + g, n) - D) * (1 - target_da); // Unlevered equiv
            const premium_eq = Equity - pure_btc_eq;
            const pv_premium = premium_eq / Math.pow(1 + r, n);
            const mnav = 1 + pv_premium / 100;
            const prem_pct = ((mnav - 1) * 100).toFixed(0);

            outputs.years.textContent = n;
            outputs.mnav.textContent = mnav.toFixed(2);
            outputs.premium.textContent = prem_pct;
        }

        Object.values(sliders).forEach(slider => {
            slider.addEventListener('input', updateValues);
        });

        updateValues(); // Initial update
    </script>

    <p>To use: Save as .html and open in browser. Sliders update real-time. Note: Simplifications - assumes no vol, perfect issuances, costs covered; real mNAV fluctuates with market sentiment.</p>
</body>
</html>
